<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Vision Language Models | Johanns Blog</title>
<meta name="keywords" content="vlm, llm">
<meta name="description" content="LLMs are boring but VLMs are awesome, let&rsquo;s see why.">
<meta name="author" content="Johann Gerberding">
<link rel="canonical" href="http://localhost:1313/posts/2024-08-23-vision-language-models/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a0264e6a2df146fcf73b7783950d40c4be7e8efa44c2889964f6ec37304880d9.css" integrity="sha256-oCZOai3xRvz3O3eDlQ1AxL5&#43;jvpEwoiZZPbsNzBIgNk=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2024-08-23-vision-language-models/">

<meta name="twitter:title" content="Vision Language Models | Johanns Blog" />
<meta name="twitter:description" content="LLMs are boring but VLMs are awesome, let&rsquo;s see why." />
<meta property="og:title" content="Vision Language Models | Johanns Blog" />
<meta property="og:description" content="LLMs are boring but VLMs are awesome, let&rsquo;s see why." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/2024-08-23-vision-language-models/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2024-08-23T10:00:00&#43;02:00" />
  <meta property="article:modified_time" content="2024-08-23T10:00:00&#43;02:00" /><meta property="og:site_name" content="Johann&#39;s Blog" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vision Language Models",
      "item": "http://localhost:1313/posts/2024-08-23-vision-language-models/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vision Language Models | Johanns Blog",
  "name": "Vision Language Models",
  "description": "LLMs are boring but VLMs are awesome, let\u0026rsquo;s see why.",
  "keywords": [
    "vlm", "llm"
  ],
  "wordCount" : "3540",
  "inLanguage": "en",
  "datePublished": "2024-08-23T10:00:00+02:00",
  "dateModified": "2024-08-23T10:00:00+02:00",
  "author":{
    "@type": "Person",
    "name": "Johann Gerberding"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/2024-08-23-vision-language-models/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Johanns Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script><script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'light';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Johanns Blog (Alt + H)">Johanns Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="posts" class="active"
                ><i class='fa fa-heart'></i>posts
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="tags"
                ><i class='fa fa-heart'></i>tags
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/reading/" title="reading"
                ><i class='fa fa-heart'></i>reading
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about-me/" title="about"
                ><i class='fa fa-heart'></i>about
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Vision Language Models<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup></h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>August 23, 2024</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="http://localhost:1313/tags/vlm/">Vlm</a><a href="http://localhost:1313/tags/llm/">Llm</a></span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select: text;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" style="user-select: text;"></path><polyline points="14 2 14 8 20 8" style="user-select: text;"></polyline><line x1="16" y1="13" x2="8" y2="13" style="user-select: text;"></line><line x1="16" y1="17" x2="8" y2="17" style="user-select: text;"></line><polyline points="10 9 9 9 8 9" style="user-select: text;"></polyline></svg>
  <span>3540 words</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>17 min</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#families-of-vlms" aria-label="Families of VLMs">Families of VLMs</a><ul>
                        
                <li>
                    <a href="#contrastive-based-methods" aria-label="Contrastive-based Methods">Contrastive-based Methods</a><ul>
                        
                <li>
                    <a href="#clip" aria-label="CLIP">CLIP</a></li>
                <li>
                    <a href="#llip" aria-label="Llip">Llip</a></li></ul>
                </li>
                <li>
                    <a href="#vlms-with-masking-objectives" aria-label="VLMs with Masking Objectives">VLMs with Masking Objectives</a><ul>
                        
                <li>
                    <a href="#flava" aria-label="FLAVA">FLAVA</a></li>
                <li>
                    <a href="#maskvlm" aria-label="MaskVLM">MaskVLM</a></li></ul>
                </li>
                <li>
                    <a href="#generative-based-vlms" aria-label="Generative-based VLMs">Generative-based VLMs</a><ul>
                        
                <li>
                    <a href="#coca" aria-label="CoCa">CoCa</a></li>
                <li>
                    <a href="#cm3leon" aria-label="CM3leon">CM3leon</a></li></ul>
                </li>
                <li>
                    <a href="#vlms-from-pretrained-backbones" aria-label="VLMs from Pretrained Backbones">VLMs from Pretrained Backbones</a><ul>
                        
                <li>
                    <a href="#idefics" aria-label="Idefics">Idefics</a></li>
                <li>
                    <a href="#internvl" aria-label="InternVL">InternVL</a></li>
                <li>
                    <a href="#qwen2-vl" aria-label="Qwen2-VL">Qwen2-VL</a></li>
                <li>
                    <a href="#minicpm-v" aria-label="MiniCPM-V">MiniCPM-V</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#training" aria-label="Training">Training</a><ul>
                        
                <li>
                    <a href="#data" aria-label="Data">Data</a></li>
                <li>
                    <a href="#grounding" aria-label="Grounding">Grounding</a></li>
                <li>
                    <a href="#alignment" aria-label="Alignment">Alignment</a></li></ul>
                </li>
                <li>
                    <a href="#evaluation" aria-label="Evaluation">Evaluation</a><ul>
                        
                <li>
                    <a href="#benchmarks" aria-label="Benchmarks">Benchmarks</a></li>
                <li>
                    <a href="#huggingface-vlm-leaderboard" aria-label="HuggingFace VLM Leaderboard">HuggingFace VLM Leaderboard</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">¶</a></h2>
<p align="justify">
Vision Language Models (VLM) are multimodal models that can learn from text and images and generate text as an output (some are able to generate images too). Typical use cases for this range from image chatting, image recognition, visual question answering to image captioning, document understanding and more. In addition to that some models are also able to perform object detection, segmentation or reasoning about relative positions of objects (which is kinda fire).
</p>
<p align="justify">
The focus of this post lies on open source models just because we have information about their architecture, datasets and training processes. VLMs currently are far from being perfect, there exist a lot of open questions, challenges when building them and problems that have to be addressed e.g.:
</p>
<ul>
<li>bad understanding of spatial relationships</li>
<li>bad at counting (without complicated engineering overhead that relies on additional data annotation or other hacks)</li>
<li>lack understanding of attributes and ordering</li>
<li>ignorance of parts of the input prompt (need for a lot of prompt engineering to produce the results you want)</li>
<li>hallucinations (like in LLMs)</li>
</ul> 
<p align="justify">
In the following I will categorize them by their training paradigm like in [2] and will go over some prominent examples. There exist way to many models to cover them all so if this overview here isn't enough and you want more information check out <a href="https://huggingface.co/models?pipeline_tag=image-text-to-text&sort=trending">huggingface models</a>, this cool <a href="https://huggingface.co/collections/merve/vision-language-models-papers-66264531f7152ac0ec80ceca">paper collection</a> or <a href="https://paperswithcode.com/">paperswithcode</a>. 
</p>
<h2 id="families-of-vlms">Families of VLMs<a hidden class="anchor" aria-hidden="true" href="#families-of-vlms">¶</a></h2>
<p align="justify">
One way to categorize VLMs is based on the training paradigm like in [2]:
</p>
<ul>
<li><b>contrastive</b>: Leverage pairs of positive and negative examples.</li>
<li><b>masking</b>: Leverage reconstruction of masked image patches given some unmasked text.</li>
<li><b>pretrained backbones</b>: Combine a pretrained LLM with a pretrained image encoder and then learn a mapping between those two.</li>
<li><b>generative</b>: Generate captions and images.</li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/families_of_vlms.png#center"
         alt="Families of Vision Language Models" width="90%"/> <figcaption>
            <p>Figure 1. Families of VLMs [2]</p>
        </figcaption>
</figure>

<p align="justify">
The paradigms are not mutually exclusive and many approaches we explore in this post rely on a mix of those training strategies. In the following we will describe some approaches for each paradigm.
</p>
<h3 id="contrastive-based-methods">Contrastive-based Methods<a hidden class="anchor" aria-hidden="true" href="#contrastive-based-methods">¶</a></h3>
<p align="justify">
In this section I am presenting two contrastive-based VLMs, the very popular CLIP model from OpenAI and one of the successor models from Meta called Llip.
</p>
<h4 id="clip">CLIP<a hidden class="anchor" aria-hidden="true" href="#clip">¶</a></h4>
<p align="justify">
CLIP (<b>C</b>ontrastive <b>L</b>anguage <b>I</b>mage <b>P</b>re-training) was one of those models created by OpenAI which were really open (you know back in the days OpenAI was really open and cool). The pre-training task here was not to predict the exact caption for each image but to predict which whole caption to pair with a certain image. This switch from a predictive objective (so the classic ML approach with labels) to a contrastive one lead to a 4x efficiency improvement. To train this model the authors leveraged captions from the internet and collected a huge dataset of 400 million image-text-pairs which they called WIT for WebImageText. Another advantage of prediction captions instead of e.g. classes was a better and more flexible zero-shot transfer capability of the model. The figure down below gives a good overview of the approach.
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/clip.png#center"
         alt="CLIP approach overview" width="100%"/> <figcaption>
            <p>Figure 2. CLIP approach overview [3]</p>
        </figcaption>
</figure>

<p align="justify">
The CLIP model is trained using a batch of $N$ image-text pairs. The training objective is to predict which of the $N×N$ possible image-text pairings within the batch actually occurred. To achieve this, CLIP learns a multimodal embedding space by jointly training an image encoder and a text encoder. The goal is to maximize the cosine similarity between the image and text embeddings of the $N$ correct (real) pairs in the batch while minimizing the cosine similarity for the incorrect pairings. For optimization, a symmetric cross-entropy loss, also known as InfoNCE loss, is applied to the similarity scores. The following pseudocode outlines this procedure.
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/clip_code.png#center"
         alt="CLIP training pseudocode" width="60%"/> <figcaption>
            <p>Figure 3. CLIP training pseudocode [3]</p>
        </figcaption>
</figure>

<p align="justify">
As the image encoder, the authors trained 5 ResNet and 3 ViT versions and found the ViT-L/14@336px version to perform the best. The text encoder is a 63M parameter Transformer (12 layers) with a vocab size of ~49K. The model showed strong zero-shot performance on ImageNet classification task (same as the original ResNet50). Some of the limitations of CLIP were e.g. that the zero-shot performance on more finegrained vision tasks was quite bad (like differenciating between different car models), on some tasks it was random (like counting objects) and it was not as good as you would expect on simple out of distribution tasks like MNIST (just 88% accuracy).  
</p>
<h4 id="llip">Llip<a hidden class="anchor" aria-hidden="true" href="#llip">¶</a></h4>
<p align="justify">
One of the problems with CLIP was, that there are a thousand ways to caption an image, based on the fact that the caption could describe only specific regions of an image or specific objects. To better model the visual richness of an image, a training objective of a vision language model should aim to capture all the possible text descriptions. This is what the authors of Llip, <b>L</b>atent <b>L</b>anguage <b>I</b>mage <b>P</b>retraining, try to do. To enable the prediction of different representations from a fixed image, they implemented the image-to-text representation function as a one-to-many mapping. This is achieved by augmenting the visual encoder with a latent variable that captures context information. The contextual latent is inferred from the caption and used to modulate the representation. The visual encoder is implemented as a Vision Transformer that outputs $K$ learnable mixture tokens in addition to the visual tokens. These mixture tokens should capture different visual aspects of an image. Figure 4 down below shows this simple modification of CLIP.
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/clip_vs_llip.png#center"
         alt="CLIP vs. Llip" width="80%"/> <figcaption>
            <p>Figure 4. CLIP vs. Llip [4]</p>
        </figcaption>
</figure>

<p align="justify">
The authors added a cross-attention mechanism to infer the mixture token weights as a function of the text caption. The weighted mixture defines the contextual representation that is contrasted with text representations. This leads to significant improvement of the visual representation quality as well as a more rich visual representation.
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/llip_cross_attention.png#center"
         alt="Llip Cross Attention mechanism" width="90%"/> <figcaption>
            <p>Figure 5. Llip cross-attention mechanism [4]</p>
        </figcaption>
</figure>

<p align="justify">
On zero-shot transfer classification, Llip consistently outperforms CLIP pretraining for architecture of similar size on a large set of benchmarks. Especially on zero-shot image-text and text-image retrieval, Llip consistently outperforms CLIP pretraining on COCO by 6.0% image-to-text retrieval.
</p>
<h3 id="vlms-with-masking-objectives">VLMs with Masking Objectives<a hidden class="anchor" aria-hidden="true" href="#vlms-with-masking-objectives">¶</a></h3>
<p align="justify">
Masking is a commonly used technique in deep learning research. It can be viewed as a specific form of denoising autoencoder in which the noise has a spatial structure. In 2019 the authors of the BERT paper used Masked-Language-Modeling (MLM) to predict missing text tokens in a sentence. More recently the same concept (Masked-Image-Modeling) was used in the vision space to learn strong visual representations like in I-JEPA. In the following we are going through two approaches that combined those techniques to train a VLM, FLAVA [5] and MaskVLM [6].
</p>
<h4 id="flava">FLAVA<a hidden class="anchor" aria-hidden="true" href="#flava">¶</a></h4>
<p align="justify">
Contrastive methods like CLIP aren't easy usable on multimodal problems that require dealing with both modalities at the same time. Many of the more recent models that rely on early fusion and shared self-attention across modalities often perform very bad on vision-only or language-only tasks. The goal of the authors was to create a single "foundation" model that is good at vision tasks, language tasks and cross- and multi-modal tasks. FLAVA consists of three models, an image encoder, a text encoder and a multimodal encoder that takes as input the encoded image and text and integrates their represenations for multimodal reasoning.
</p>
<p align="justify">
The image encoder is a ViT-B/16 model with a fixed image size. It outputs is a list of hidden state vectors $\{h_{I}\}$, each corresponding to an image patch, and a classification token $h_{CLS,I}$. The text encoder has the same architecture as the vision part and outputs a hidden state vector $\{h_{T}\}$ and a text classification token $h_{CLS,T}$. The multimodal encoder also is a transformer model that fuses image and text hidden states. Over each of the hidden state vectors generated by the image and text encoder two learned linear projections are applied and an additional $[CLS_M]$ token is added before feeding this into the multimodal encoder. Like the text and image encoders, the multimodal encoder also outputs a list of hidden state vectors $\{h_{M}\}$ and a vector $h_{CLS,M}$ for the classification token. 
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/flava_overview.png#center"
         alt="Overview of the FLAVA model architecture" width="100%"/> <figcaption>
            <p>Figure 6. Overview of the FLAVA model architecture [5]</p>
        </figcaption>
</figure>

<p align="justify">
The training process consists of a joint pretraining on both unimodal and multimodal data. First the authors pretrained the text encoder, then the image encoder and then they used both pretrained encoders to train the multimodal encoder. 
For the unimodal pretraining they used established loss components. For the image encoder they used a masked image modeling (MIM) objective like in BEiT. First they tokenize the image patches with a dVAE tokenizer, then they used a classifier on top of the image encoder outputs to predict the missing tokens. Masked language modeling (MLM) was used for the text encoder as an objective with 15% of text tokens masked. For the multimodal pretraining three loss components were used:
</p>
<ul>
<li><b>Global contrastive</b> (GC) loss, like in CLIP</li>
<li><b>Masked Multimodal Modeling</b> (MMM) loss, masking of both the image patches and text tokens</li>
<li><b>Image Text Matching</b> (ITM) loss, by applying a classifier on top of the multimodal encoder to decide if the input image and text match to each other</li>
</ul>
<p align="justify">
One of the cool things of this paper is, that the authors only used public unimodal and multimodal datasets for training, 70 million image-text pairs in total (but the avg. text length was just 12 words). The validated FLAVA on 35 tasks across vision, NLP and multimodal domains and performed better or competitive on all of those tasks with the state of the art models at that time which were mostly trained on much larger and probably cleaner datasets. 
</p>
<h4 id="maskvlm">MaskVLM<a hidden class="anchor" aria-hidden="true" href="#maskvlm">¶</a></h4>
<p align="justify">
Instead of developing masked language modeling (MLM) and masked image modeling (MIM) independently, the authors propose to build joint masked vision and language modeling, where the masked signal of one modality is reconstructed with the help from another modality. The masked signal reconstruction of one modality conditioned on another modality can also implicitly learn cross-modal alignment between language tokens and image patches. This works especially well in scenarios with limited data. Figure 7 illustrates the difference between this new paradigm and the classic MIM and MLM based approaches.
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/maskvlm_idea.png#center"
         alt="Left MIM and MLM and right the MaskVLM idea" width="85%"/> <figcaption>
            <p>Figure 7. Left: MIM &amp; MLM; Right: Masked Vision Language Modeling [6]</p>
        </figcaption>
</figure>

<p align="justify">
There are two main types of pre-training objectives in this model. The first is masked vision and language modeling. Here, transformer-based models are used as image and text encoders to extract features from both modalities. These features are then processed by image and text cross-modality encoders, which consist of three cross-attention blocks. These blocks allow the text and image features to interact, enhancing the representation of each by leveraging information from the other. The second objective is multimodal alignment, which includes image-text contrastive learning (ITC) and image-text matching (ITM). These methods align the representations of images and text to ensure they correspond accurately. For more detailed information, you can refer to the original paper.
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/maskvlm_architecture.png#center"
         alt="MaskVLM model architecture" width="90%"/> <figcaption>
            <p>Figure 8. Overview of the MaskVLM model architecture [6]</p>
        </figcaption>
</figure>

<p align="justify">
MaskVLM is very data efficient, it especially shines in limited data scenarios where only ∼40% of data used by the state-of-the-art models is sufficient to match their performance.
</p>
<h3 id="generative-based-vlms">Generative-based VLMs<a hidden class="anchor" aria-hidden="true" href="#generative-based-vlms">¶</a></h3>
<p align="justify">
In contrast to the paradigms above, that mostly operate on latent representations we will now look at generative VLM that are trained to generate text and images. We are looking at two methods in more detail, <b>CoCa</b> which learns to generate text and <b>Chameleon</b> which is a multimodal generative model that can generate text and images. Before we delve deeper I will list some of the advantages of generative classifiers and why this training paradigm can be a good idea: 
</p>
<ul>
<li>more effective robustness which means better out-of-distribution performance</li>
<li>better on compositional reasoning tasks than discriminative methods like CLIP</li> 
<li>more shape bias and better alignment with human judgement</li>
<li>can be jointly adapted with discriminative models at test time using only unlabeled test samples which improves classification, segmentation and depth prediction performance</li>
</ul>
<h4 id="coca">CoCa<a hidden class="anchor" aria-hidden="true" href="#coca">¶</a></h4>
<ul>
<li><b>Co</b>ntrastive <b>Ca</b>ptioner (CoCa) is an image-text encoder-decoder foundation model pretrained jointly with a contrastive and a captioning loss, which makes it a combination of contrastive approaches like CLIP and generative methods.</li>
<li>decoder is decoupled into two parts, a unimodal decoder and a multimodal decoder</li>
<li>omit cross-attention in unimodal decoder layers to encode text-only representations, and cascade multimodal decoder layers cross-attending to image encoder outputs to learn multimodal image-text representation</li>
</ul>
<p align="justify">
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/coca_architecture.png#center"
         alt="CoCa model architecture, training objectives and pseudocode" width="100%"/> <figcaption>
            <p>Figure 9. Overview of the CoCa model architecture and training objectives [10]</p>
        </figcaption>
</figure>

<p align="justify">
- quick transfer to downstream tasks with zero-shot transfer or minimal task adaptation
</p>
<h4 id="cm3leon">CM3leon<a hidden class="anchor" aria-hidden="true" href="#cm3leon">¶</a></h4>
<p align="justify">
- retrieval augmented, token based, decoder-only multimodal model capable of generating text and images
- uses the CM3 model architecture as basis and benefits a lot from scaling and instruction tuning
- CM3 uses a VQGAN to turn images into 1024 tokens 
- trained with a recipe adapted from text-only language models, including a large scale retrieval-augmented pretraining stage and a second multi-task supervised finetuning stage
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/ra-cm3_architecture.png#center"
         alt="RA-CM3 model architecture" width="100%"/> <figcaption>
            <p>Figure 10. Overview of the RA-CM3 model architecture and training pipeline [12]</p>
        </figcaption>
</figure>

<p align="justify">
</p>
<h3 id="vlms-from-pretrained-backbones">VLMs from Pretrained Backbones<a hidden class="anchor" aria-hidden="true" href="#vlms-from-pretrained-backbones">¶</a></h3>
<p align="justify">
- costly to train from scratch because you need hundreds or thousands of GPUs while having to use millions of image-text pairs 
- to avoid these high costs there is a lot of research in the area of leveraging existing unimodal models 
- just learn to map between the text and image modalities which requires a low amount of compute resources
- in this section we are looking at some of the best open source vision language models out there: the Idefics series, InternVL1.5 and 2, Qwen2-VL
</p>
<h4 id="idefics">Idefics<a hidden class="anchor" aria-hidden="true" href="#idefics">¶</a></h4>
<p>Idefics1:</p>
<ul>
<li>introduction of the OBELICS dataset which consists of interleaved image-text documents comprising 141 million web pages extracted from Common Crawl, 353 million associated images and 115 billion text tokens</li>
<li>one of the advantages of OBELICS is the amount and detail of text per image, which is much bigger than in other image-text datasets</li>
<li>Figure X down below shows the whole dataset creation process</li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/obelics.png#center"
         alt="Generation process of the OBELICS dataset" width="90%"/> <figcaption>
            <p>Figure 9. Overview of the OBELICS generation process [7]</p>
        </figcaption>
</figure>

<ul>
<li>with that dataset the authors created two vision language models called &ldquo;Idefics&rdquo;, a 9 and a 80 billion parameter model</li>
<li>it is based on the Flamingo architecture, comprised of two frozen unimodal backbones, Llama for the language encoder and OpenCLIP for the vision part</li>
<li>learnable cross-attention Transformer blocks and Perceiver blocks are added to connect both unimodal encoders</li>
<li>best results on a combination of the LAION and the OBELICS datasets</li>
</ul>
<p>Idefics2:</p>
<ul>
<li>
<p>investigate which choices matter when building VLMs</p>
</li>
<li>
<p>focus on two design choices</p>
<ul>
<li>model architecture, especially strategy of how to fuse image and text information</li>
<li>training procedure</li>
</ul>
</li>
<li>
<p>main findings:</p>
<ul>
<li>progress in vision-language models is largely driven by the progress of pretrained unimodal backbones (LLM is more important than Vision Encoder, but there are no really good vision encoders out there and I think InternVL will show that this finding is not true)</li>
<li>fully autoregressive architecture outperforms cross-attention, but it requires modifications to the optimization procedure to ensure a stable training</li>
<li>reducing the number of visual tokens with learned pooling significantly improves compute efficiency while also improving performance on downstream tasks (efficiency yes but performance is another thing which is hard to prove without a very good vision encoder)</li>
<li>splitting images into subimages allow trading compute efficiency for more performance during inference, especially noticeable for tasks that require text reading capabilities</li>
</ul>
</li>
<li>
<p>based on the findings described above the authors created Idefics2, a 8B parameter VLM that achieves state-of-the-art performance within its size category</p>
</li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/idefics2.png#center"
         alt="Idefics2 model architecture" width="90%"/> <figcaption>
            <p>Figure 10. Idefics2 model architecture [8]</p>
        </figcaption>
</figure>

<ul>
<li>vision encoder = SigLIP-SO400M, LLM = Mistral-7B-v0.1</li>
<li>datasets for training: OBELICS, LAION COCO, PMD, OCR-IDL, PDFA</li>
</ul>
<p>Idefics3:</p>
<ul>
<li>test</li>
</ul>
<p align="justify">
</p>
<h4 id="internvl">InternVL<a hidden class="anchor" aria-hidden="true" href="#internvl">¶</a></h4>
<p align="justify">
</p>
<h4 id="qwen2-vl">Qwen2-VL<a hidden class="anchor" aria-hidden="true" href="#qwen2-vl">¶</a></h4>
<p align="justify">
</p>
<h4 id="minicpm-v">MiniCPM-V<a hidden class="anchor" aria-hidden="true" href="#minicpm-v">¶</a></h4>
<p>2.5 &amp; 2.6</p>
<p align="justify">
- remaining challenges prevent VLMs from being used in real world applications, the most significant one is the high cost of running those big models 
- most VLMs have to be deployed on high-performance cloud servers, which greatly limits their application scope (mobile, offline, privacy-protective)
- MiniCPM is a model family that tries to change that
- model have strong performance on general benchmarks and especially OCR capabilities, has multilingual support for more than 30 languages and you can run these models on mobile phones
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/minicpm.png#center"
         alt="MiniCPM-V-2.5 model architecture" width="100%"/> <figcaption>
            <p>Figure 11. MiniCPM-V-2.5 model architecture []</p>
        </figcaption>
</figure>

<p align="justify">
- three key modules: visual encoder, compression layer, LLM 
- input image is encoded by a SigLIP SoViT-400m/14, utilizing the adaptive visual encoding approach proposed by LLaVA-UHD
- the compression layer has a perceiver resampler structure with one layer cross-attention
- the compressed visual tokens along with the text input are fed into the LLM for conditional text generation
- image partitioning -> slice encoding (and resizing so that the slice size matches the ViT input size) -> token compression (1024 tokens per image slice, compressed with cross attention layer to 64/96 tokens)
- 3 phase training process: pretraining, supervised fine-tuning, RLAIF-V
- RLAIF-V is a framework for improving trustworthiness and reduce hallucinations 
</p>
<h2 id="training">Training<a hidden class="anchor" aria-hidden="true" href="#training">¶</a></h2>
<p align="justify">
- scale is very important to model performance but a lot of companies and academic labs don't have the resources to aquire the amount of compute needed to train such models
- recently researchers found that a data curation pipeline makes it possible to beat the scaling law
</p>
<figure class="align-center ">
    <img loading="lazy" src="/imgs/vlms/training.png#center"
         alt="Important training decisions to make" width="100%"/> <figcaption>
            <p>Figure X. Important decisions to make when training VLMs [2]</p>
        </figcaption>
</figure>

<p align="justify">
- in the following we will explore the importance of data and recipes that are used to create high quality datasets for VLM training
- in addition we will go into grounding, alignment with human preferences and some recipes about choosing the right model for your use case
</p>
<h3 id="data">Data<a hidden class="anchor" aria-hidden="true" href="#data">¶</a></h3>
<p align="justify">
The quality and organization of data play a critical role in the successful training of Vision-Language Models (VLMs). Due to the complex nature of these models, which need to understand both visual and textual inputs, effective data management through pruning, augmentation, and quality control is essential to achieving optimal performance. Data pruning is a crucial step in refining the datasets used to train VLMs. Pruning techniques fall into three main categories:
</p>
<ul>
<li><b>Heuristic-based pruning</b> involves the use of rules to eliminate low-quality image-text pairs. This can be done through unimodal filtering, where low-quality captions (e.g., lacking complexity or containing non-English text) or inappropriate images (based on size or aspect ratio) are removed. Multimodal filtering further refines data by using image classifiers to detect when objects in the image do not align with the associated text, or by filtering out examples where the majority of text in the caption appears directly within the image itself.</li>
<li><b>Bootstrapping methods</b> leverage pre-trained VLMs to rank image-text pairs based on their multimodal alignment, using metrics such as CLIPScore. This approach helps prioritize data that better represents meaningful relationships between the visual and textual components, further refining the dataset for training.</li>
<li><b>Diversity and balance techniques</b> aim to create datasets that not only contain high-quality pairs but also represent a wide variety of content. Ensuring diversity in objects, actions, and attributes across different modalities can prevent bias and improve the model’s generalization capability.</li>
</ul>
<p align="justify">
In addition to pruning, the generation of synthetic data has become an effective strategy for enhancing VLM performance. For example, LLMs can generate captions, which can then be used by text-to-image models to create corresponding images. This helps to supplement the training data, especially in areas where real-world examples may be limited or lacking. Data augmentation techniques, such as adding variations to existing image-text pairs (e.g., rotating or cropping images, rewording captions), further contribute to improving model robustness by exposing the VLM to a wider range of inputs.
</p>
<p align="justify">
Data quality is paramount when training VLMs or any other AI model, but assessing the quality of multimodal and interleaved data remains a challenge. The lack of a standardized method for evaluating such data complicates the task, as quality often depends on the subjective judgment of what constitutes a "good" image-text pair. This is an active area of research, as models continue to evolve and demand increasingly refined datasets for training. Despite the challenges, curated datasets such as OBELICS, which contain interleaved data from multiple modalities, have shown promising results. These datasets are carefully constructed to ensure a rich variety of content, making them valuable resources for VLM training.
</p>
<p align="justify">
In summary, data plays a foundational role in training vision-language models, and techniques such as data pruning, augmentation, and synthetic data generation are essential for improving VLM performance. However, assessing data quality remains an open challenge that continues to evolve alongside advancements in multimodal learning.
</p>
<h3 id="grounding">Grounding<a hidden class="anchor" aria-hidden="true" href="#grounding">¶</a></h3>
<p align="justify">
- grounding describes the ability to correctly map text with visual clues 
</p>
<h3 id="alignment">Alignment<a hidden class="anchor" aria-hidden="true" href="#alignment">¶</a></h3>
<p align="justify">
</p>
<h2 id="evaluation">Evaluation<a hidden class="anchor" aria-hidden="true" href="#evaluation">¶</a></h2>
<p align="justify">
</p>
<h3 id="benchmarks">Benchmarks<a hidden class="anchor" aria-hidden="true" href="#benchmarks">¶</a></h3>
<p align="justify">
</p>
<h3 id="huggingface-vlm-leaderboard">HuggingFace VLM Leaderboard<a hidden class="anchor" aria-hidden="true" href="#huggingface-vlm-leaderboard">¶</a></h3>
<ul>
<li>let&rsquo;s take a look at the current Huggingface VLM Leaderboard</li>
</ul>
<p align="justify">
</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">¶</a></h2>
<p><a name="references"></a></p>
<p><a href="https://huggingface.co/blog/vlms">[1]</a> M. Noyan &amp; E. Beeching &ldquo;Vision Language Models Explained&rdquo; (2024).</p>
<p><a href="https://arxiv.org/pdf/2405.17247">[2]</a> Bordes et al. &ldquo;An Introduction to Vision-Language Modeling&rdquo; (2024)</p>
<p><a href="https://arxiv.org/pdf/2103.00020">[3]</a> Radford et al. &ldquo;Learning Transferable Visual Models from Natural Language Supervision&rdquo; (2021)</p>
<p><a href="https://arxiv.org/pdf/2405.00740">[4]</a> Lavoie et al. &ldquo;Modeling Caption Diversity in Contrastive Vision-Language Pretraining&rdquo; (2024)</p>
<p><a href="https://arxiv.org/pdf/2112.04482">[5]</a> Singh et al. &ldquo;FLAVA: A Foundational Language And Vision Alignment Model&rdquo; (2021)</p>
<p><a href="https://arxiv.org/pdf/2208.02131">[6]</a> Kwon et al. &ldquo;Masked Vision and Language Modeling for Multi-Modal Represenation Learning&rdquo; (2023)</p>
<p><a href="https://arxiv.org/pdf/2306.16527">[7]</a> Laurencon et al. &ldquo;OBELICS: An Open Web-Scaled Filtered Dataset of Interleaved Image-Text Documents&rdquo; (2023)</p>
<p><a href="https://arxiv.org/pdf/2405.02246">[8]</a> Laurencon et al. &ldquo;What matters when building vision-language models?&rdquo; (2024)</p>
<p><a href="https://arxiv.org/pdf/2408.12637">[9]</a> Laurencon et al. &ldquo;Building and better understanding vision-language models: insights and future directions&rdquo; (2024)</p>
<p><a href="https://arxiv.org/pdf/2205.01917">[10]</a> Yu et al. &ldquo;CoCa: Contrastive Captioners are Image-Text Foundation Models&rdquo; (2022)</p>
<p><a href="https://arxiv.org/pdf/2309.02591">[11]</a> Yu et al. &ldquo;Scaling Autoregressive Multi-Modal Models: Pre-Training and Instruction Tuning&rdquo; (2023)</p>
<p><a href="https://arxiv.org/pdf/2211.12561">[12]</a> Yasunaga et al. &ldquo;Retrieval-Augmented Multimodal Language Modeling&rdquo; (2023)</p>
<p><a href="https://arxiv.org/pdf/2201.07520">[13]</a> Aghajanyan et al. &ldquo;CM3: A Causal Masked Multimodal Model of The Internet&rdquo; (2022)</p>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/2024-08-08-world-models/">
    <span class="title">Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg>
    </span>
    <br>
    <span>World Models for Autonomy</span>
  </a>
</nav>

  </footer>
    <div class="comments-separator"></div>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2024 <a href="http://localhost:1313/">Johanns Blog</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied!';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>
<script>
  mediumZoom('.entry-cover img');
  mediumZoom('.post-content img:not([no-zoom])');
</script>

</body>

</html>
